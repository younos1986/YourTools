using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using YourTools.Mapper.CodeGeneration.Models;

namespace YourTools.Mapper.CodeGeneration
{
    public class MapperCodeGenerator
    {
        private string Qualify(string ns, string type)
            => string.IsNullOrWhiteSpace(ns) ? $"global::{type}" : $"global::{ns}.{type}";

        public void Generate(SourceProductionContext spc,
            Compilation compilation,
            List<MappingInfo> mappings)
        {
            if (!mappings.Any()) return;
            // Service registration
            var srBuilder = new StringBuilder();
            BuildServiceRegistration(srBuilder, mappings);
            spc.AddSource("RegisterMappingHandlers.g.cs", Microsoft.CodeAnalysis.Text.SourceText.From(srBuilder.ToString(), Encoding.UTF8));
            // Combined handlers
            var uniqueMappings = mappings.Select(m => (m.Source, m.Destination)).Distinct().ToList();
            foreach (var (source, destination) in uniqueMappings)
            {
                var sourceBuilder = new StringBuilder();
                var mapping = mappings.FirstOrDefault(m => m.Source == source && m.Destination == destination);
                BuildCombinedMapperHandler(sourceBuilder, source, destination, mapping, mappings);
                spc.AddSource($"Map{source}To{destination}.g.cs", Microsoft.CodeAnalysis.Text.SourceText.From(sourceBuilder.ToString(), Encoding.UTF8));
            }
            // Dispatcher
            var dispUnique = uniqueMappings;
            var sb = new StringBuilder();
            
            sb.AppendLine("// <auto-generated />");
            sb.AppendLine("using System;");
            sb.AppendLine("using System.Runtime.CompilerServices;");
            sb.AppendLine("using YourTools.Mapper;");
            
            foreach (var ns in GetRequiredNamespaces(mappings)) 
                sb.AppendLine($"using {ns};");
            
            sb.AppendLine();
            sb.AppendLine("namespace YourTools.Mapper.Generated");
            sb.AppendLine("{");
            sb.AppendLine("    // This static helper provides ultra-fast dispatch for generated mappings without reflection.");
            sb.AppendLine("    // It uses a sequence of exact type checks (jump table style) to route source->destination conversions.");
            sb.AppendLine("    // Generic TryMap<TSource,TDestination> covers strongly-typed calls; TryMapObj handles runtime (object) scenarios.");
            sb.AppendLine("    // Collection variants (List<> / array combinations) are inlined so we avoid per-element reflection overhead.");
            sb.AppendLine($"    // Generated at {DateTime.Now:O}");
            sb.AppendLine("    internal static class __GeneratedMappingDispatcherStatic");
            sb.AppendLine("    {");
            
            // Array mapping function
            sb.AppendLine("        [MethodImpl(MethodImplOptions.AggressiveInlining)]");
            sb.AppendLine("        internal static bool TryMapArray(object source, Type sourceType, Type destType, out object result)");
            sb.AppendLine("        {");
            sb.AppendLine("            if (source is null) { result = null!; return true; }");
            foreach (var (src, dst) in dispUnique)
            {
                sb.AppendLine($"            if (sourceType == typeof({src}[]) && destType == typeof({dst}[])) {{ result = Map{src}To{dst}.MapArrayTo{dst}(({src}[])source)!; return true; }}");
            }
            sb.AppendLine("            result = null!; return false;");
            sb.AppendLine("        }");
            sb.AppendLine();
            
            // List mapping function
            sb.AppendLine("        [MethodImpl(MethodImplOptions.AggressiveInlining)]");
            sb.AppendLine("        internal static bool TryMapList(object source, Type sourceType, Type destType, out object result)");
            sb.AppendLine("        {");
            sb.AppendLine("            if (source is null) { result = null!; return true; }");
            foreach (var (src, dst) in dispUnique)
            {
                sb.AppendLine($"            if (sourceType == typeof(System.Collections.Generic.List<{src}>) && destType == typeof(System.Collections.Generic.List<{dst}>)) {{ result = Map{src}To{dst}.MapListTo{dst}((System.Collections.Generic.List<{src}>)source)!; return true; }}");
            }
            sb.AppendLine("            result = null!; return false;");
            sb.AppendLine("        }");
            sb.AppendLine();
            
            // TryMapSingleObject to only handle single object mapping
            sb.AppendLine("        [MethodImpl(MethodImplOptions.AggressiveInlining)]");
            sb.AppendLine("        internal static bool TryMapSingleObject(object source, Type sourceType, Type destType, out object result)");
            sb.AppendLine("        {");
            sb.AppendLine("            if (source is null) { result = null!; return true; }");
            foreach (var (src, dst) in dispUnique)
            {
                var mapping = mappings.FirstOrDefault(m => m.Source == src && m.Destination == dst);
                if (mapping != null)
                {
                    sb.AppendLine($"            if (sourceType == typeof({src}) && destType == typeof({dst})) {{ result = (({src})source).MapTo{dst}(); return true; }}");
                }
                else
                {
                    sb.AppendLine($"            // No mapping method for {src} => {dst}");
                }
            }
            sb.AppendLine("            result = null!; return false;");
            sb.AppendLine("        }");
            sb.AppendLine("    }");
            sb.AppendLine();
            
            // Emit the IGeneratedMappingDispatcher
            sb.AppendLine("    public sealed class GeneratedMappingDispatcher : IGeneratedMappingDispatcher");
            sb.AppendLine("    {");
            sb.AppendLine("        public bool TryMapArray(object source, Type sourceType, Type destType, out object result)");
            sb.AppendLine("            => __GeneratedMappingDispatcherStatic.TryMapArray(source, sourceType, destType, out result);");
            sb.AppendLine();
            sb.AppendLine("        public bool TryMapList(object source, Type sourceType, Type destType, out object result)");
            sb.AppendLine("            => __GeneratedMappingDispatcherStatic.TryMapList(source, sourceType, destType, out result);");
            sb.AppendLine();
            sb.AppendLine("        public bool TryMapSingleObject(object source, Type sourceType, Type destType, out object result)");
            sb.AppendLine("            => __GeneratedMappingDispatcherStatic.TryMapSingleObject(source, sourceType, destType, out result);");
            sb.AppendLine("    }");
            sb.AppendLine("}");
            spc.AddSource("GeneratedMappingDispatcher.g.cs", Microsoft.CodeAnalysis.Text.SourceText.From(sb.ToString(), Encoding.UTF8));
        }
        
        private void BuildServiceRegistration(StringBuilder sb, List<MappingInfo> mappings)
        {
            sb.AppendLine("// <auto-generated />");
            sb.AppendLine("using Microsoft.Extensions.DependencyInjection;");
            sb.AppendLine("using YourTools.Mapper;");
            var additionalNamespaces = GetRequiredNamespaces(mappings);
            foreach (var ns in additionalNamespaces) sb.AppendLine($"using {ns};");
            sb.AppendLine();
            sb.AppendLine("namespace YourTools.Mapper.Generated");
            sb.AppendLine("{");
            sb.AppendLine("    // Provides a single extension point to register all source-generated mapping components into DI.");
            sb.AppendLine("    // Adds: IMapper (core implementation), IGeneratedMappingDispatcher (fast jump-table dispatcher),\n    // and each concrete IMap<TSource,TDestination> handler for direct resolution / testing / fallback.");
            sb.AppendLine("    // Safe to call once at application startup (idempotent with typical DI containers registering singletons).");
            sb.AppendLine($"    // Generated at {DateTime.Now:O}");
            sb.AppendLine("    public static class MappingServiceExtensions");
            sb.AppendLine("    {");
            sb.AppendLine("        /// <summary>Registers all generated mapping services (mapper, dispatcher, individual handlers).</summary>");
            sb.AppendLine("        public static IServiceCollection RegisterMappingHandlers(this IServiceCollection services, System.Action<MapperConfiguration> configure = null)");
            sb.AppendLine("        {");
            // sb.AppendLine("            var config = new MapperConfiguration();");
            // sb.AppendLine("            configure?.Invoke(config);");
            // sb.AppendLine("            services.AddSingleton(config);");
            sb.AppendLine("            services.AddSingleton<IMapper, Mapper>();");
            sb.AppendLine("            services.AddSingleton<IGeneratedMappingDispatcher, GeneratedMappingDispatcher>();");
            sb.AppendLine();
            sb.AppendLine("            return services;");
            sb.AppendLine("        }");
            sb.AppendLine("    }");
            sb.AppendLine("}");
        }

        private void BuildCombinedMapperHandler(StringBuilder sb, string source, string destination, MappingInfo mapping, List<MappingInfo> allMappings)
        {
            _ = allMappings; // suppress unused parameter warning
            sb.AppendLine("// <auto-generated />");
            sb.AppendLine("using System;");
            sb.AppendLine("using System.Linq;");
            if (mapping is { HasCustomMapping: true, CustomMappingIsStatic: false })
                sb.AppendLine("using System.Reflection;");
            sb.AppendLine("using YourTools.Mapper;");
            if (mapping != null)
            {
                var namespaces = GetRequiredNamespaces(new List<MappingInfo> { mapping });
                foreach (var ns in namespaces)
                {
                    sb.AppendLine($"using {ns};");
                }
            }
            sb.AppendLine();
            sb.AppendLine("namespace YourTools.Mapper.Generated");
            sb.AppendLine("{");
            
            // Generate static mapper class
            sb.AppendLine($"    // Generated at {DateTime.Now:O}");
            sb.AppendLine($"    public static class Map{source}To{destination}");
            sb.AppendLine("    {");
            
            if (mapping != null)
            {
                GenerateMappingMethod(sb, mapping);
            }
            else
            {
                // Fallback for cases where mapping info is not available
                GenerateFallbackMappingMethod(sb, source, destination);
            }
            
            sb.AppendLine("    }");
            sb.AppendLine("}");
        }

        private void GenerateFallbackMappingMethod(StringBuilder sb, string source, string destination)
        {
            var methodName = $"MapTo{destination}";
            // Fallback does not have namespaces; cannot reliably qualify without mapping info, keep original.
            sb.AppendLine($"        public static {destination} {methodName}({source} source)");
            sb.AppendLine("        {");
            sb.AppendLine("            if (source == null) return null;");
            sb.AppendLine();
            sb.AppendLine($"            // TODO: Implement mapping from {source} to {destination}");
            sb.AppendLine($"            throw new NotImplementedException(\"Mapping from {source} to {destination} is not implemented\");");
            sb.AppendLine("        }");
        }

        private HashSet<string> GetRequiredNamespaces(List<MappingInfo> mappings)
        {
            var namespaces = new HashSet<string>();
            
            foreach (var mapping in mappings)
            {
                if (!string.IsNullOrEmpty(mapping.SourceNamespace))
                    namespaces.Add(mapping.SourceNamespace);
                if (!string.IsNullOrEmpty(mapping.DestinationNamespace))
                    namespaces.Add(mapping.DestinationNamespace);
            }
            
            return namespaces;
        }

        private List<(string Source, string Destination)> GetUniqueMappingPairs(List<MappingInfo> mappings)
        {
            return mappings
                .Select(m => (m.Source, m.Destination))
                .Distinct()
                .ToList();
        }

        private void GenerateMappingMethod(StringBuilder sb, MappingInfo mapping)
        {
            var srcQ = Qualify(mapping.SourceNamespace, mapping.Source);
            var dstQ = Qualify(mapping.DestinationNamespace, mapping.Destination);
            var methodName = $"MapTo{mapping.Destination}";
            sb.AppendLine($"        public static {dstQ} {methodName}(this {srcQ} source)");
            sb.AppendLine("        {");
            sb.AppendLine("            if (source == null) return null;");
            sb.AppendLine();
            if (mapping.HasCustomMapping && !string.IsNullOrEmpty(mapping.CustomMappingMethod))
            {
                sb.AppendLine("            // Using user-defined custom mapping method");
                GenerateCustomMappingInvocation(sb, mapping);
            }
            else
            {
                sb.AppendLine($"            return new {dstQ}");
                sb.AppendLine("            {");
                var mappableProperties = mapping.Properties.Where(p => p.IsMappable).ToList();
                var unmappableProperties = mapping.Properties.Where(p => !p.IsMappable).ToList();
                for (int i = 0; i < mappableProperties.Count; i++)
                {
                    var prop = mappableProperties[i];
                    var comma = i < mappableProperties.Count - 1 ? "," : "";
                    var mappingCode = GeneratePropertyMappingCode(prop);
                    sb.AppendLine($"                {prop.Name} = {mappingCode}{comma}");
                }
                if (unmappableProperties.Any())
                {
                    sb.AppendLine();
                    sb.AppendLine("                // Unmappable properties:");
                    foreach (var unmappableProp in unmappableProperties)
                    {
                        sb.AppendLine($"                // {unmappableProp.Name} ({unmappableProp.Type}): {unmappableProp.UnmappableReason}");
                    }
                }
                sb.AppendLine("            };");
            }
            sb.AppendLine("        }");
            sb.AppendLine();
            sb.AppendLine($"        public static System.Collections.Generic.List<{dstQ}> MapListTo{mapping.Destination}(System.Collections.Generic.List<{srcQ}> source) => YourTools.Mapper.CodeGeneration.MapCollectionHelpers.MapList<{srcQ},{dstQ}>(source, x => x.MapTo{mapping.Destination}());");
            sb.AppendLine($"        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]");
            sb.AppendLine();
            sb.AppendLine($"        public static {dstQ}[] MapArrayTo{mapping.Destination}({srcQ}[] source)");
            sb.AppendLine($"        {{");
            sb.AppendLine($"            if (source == null) return null;");
            sb.AppendLine($"            var result = new {dstQ}[source.Length];");
            sb.AppendLine($"            for (int i = 0; i < source.Length; i++)");
            sb.AppendLine($"                result[i] = source[i].MapTo{mapping.Destination}();");
            sb.AppendLine($"            return result;");
            sb.AppendLine($"        }}");
            sb.AppendLine();
            sb.AppendLine($"        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]");
            sb.AppendLine($"        public static {dstQ}[] MapListTo{mapping.Destination}Array(System.Collections.Generic.List<{srcQ}> source)");
            sb.AppendLine($"        {{");
            sb.AppendLine($"            if (source == null) return null;");
            sb.AppendLine($"            var result = new {dstQ}[source.Count];");
            sb.AppendLine($"            for (int i = 0; i < source.Count; i++)");
            sb.AppendLine($"                result[i] = source[i].MapTo{mapping.Destination}();");
            sb.AppendLine($"            return result;");
            sb.AppendLine($"        }}");
            sb.AppendLine();
            sb.AppendLine($"        public static System.Collections.Generic.List<{dstQ}> MapArrayTo{mapping.Destination}List({srcQ}[] source) => YourTools.Mapper.CodeGeneration.MapCollectionHelpers.MapArrayToList<{srcQ},{dstQ}>(source, x => x.MapTo{mapping.Destination}());");

            if (mapping.EnableProjectionFunctions)
            {
                sb.AppendLine();
                sb.AppendLine("        /// <summary>Expression for single item projection using Map method.</summary>");
                sb.AppendLine($"        public static System.Linq.Expressions.Expression<System.Func<{srcQ}, {dstQ}>> Projection => source => source.MapTo{mapping.Destination}();");
                sb.AppendLine();
                sb.AppendLine("        /// <summary>Expression for List<TSource> projection using list mapping method.</summary>");
                sb.AppendLine($"        public static System.Linq.Expressions.Expression<System.Func<System.Collections.Generic.List<{srcQ}>, System.Collections.Generic.List<{dstQ}>>> ListProjection => list => MapListTo{mapping.Destination}(list);");
                sb.AppendLine();
                sb.AppendLine($"        public static readonly System.Func<System.Collections.Generic.List<{srcQ}>, System.Collections.Generic.List<{dstQ}>> ListProjectionCompiled = ListProjection.Compile();");
                sb.AppendLine();
                sb.AppendLine("        /// <summary>Expression for array projection using array mapping method.</summary>");
                sb.AppendLine($"        public static System.Linq.Expressions.Expression<System.Func<{srcQ}[], {dstQ}[]>> ArrayProjection => array => MapArrayTo{mapping.Destination}(array);");
                sb.AppendLine();
                sb.AppendLine($"        public static readonly System.Func<{srcQ}[], {dstQ}[]> ArrayProjectionCompiled = ArrayProjection.Compile();");
            }
            // End GenerateMappingMethod
        }

        private void GenerateCustomMappingInvocation(StringBuilder sb, MappingInfo mapping)
        {
            var profileFullName = mapping.CustomMappingProfileFullName;
            var method = mapping.CustomMappingMethod;
            if (!string.IsNullOrEmpty(profileFullName))
            {
                if (mapping.CustomMappingIsStatic)
                {
                    sb.AppendLine($"            return {profileFullName}.{method}(source);");
                }
                else
                {
                    sb.AppendLine($"            var __profileType = typeof({profileFullName});");
                    sb.AppendLine("            var __instance = Activator.CreateInstance(__profileType);");
                    sb.AppendLine($"            var __method = __profileType.GetMethod(\"{method}\", BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public);");
                    sb.AppendLine("            if (__method == null) throw new InvalidOperationException(\"Custom mapping method not found: {profileFullName}." + method + "\");");
                    sb.AppendLine($"            return ({mapping.Destination})__method.Invoke(__instance, new object[] {{ source }});");
                }
            }
            else
            {
                sb.AppendLine($"            throw new NotImplementedException(\"Could not resolve custom mapping method '{method}' for {mapping.Source}->{mapping.Destination}\");");
            }
        }

        private string GeneratePropertyMappingCode(PropertyMapping prop)
        {
            // Check if this property has a custom mapping expression
            if (prop.IsCustomMapped && !string.IsNullOrEmpty(prop.CustomMappingExpression))
            {
                // Use the custom mapping expression from the ForMember call
                return prop.CustomMappingExpression;
            }
            
            switch (prop.MappingType)
            {
                case MappingType.Direct:
                    return $"source.{prop.SourcePropertyName}";

                case MappingType.NullableToNonNullable:
                    return GenerateNullableToNonNullableMapping(prop);

                case MappingType.NonNullableToNullable:
                    return $"source.{prop.SourcePropertyName}"; // Direct assignment works for non-nullable to nullable

                case MappingType.Deep:
                    var sourceElementType = ExtractTypeName(prop.SourceType);
                    var destElementType = ExtractTypeName(prop.Type);
                    return $"source.{prop.SourcePropertyName} == null ? null : Map{sourceElementType}To{destElementType}.MapTo{destElementType}(source.{prop.SourcePropertyName})";

                case MappingType.CollectionDirect:
                    return GenerateCollectionDirectMapping(prop);

                case MappingType.CollectionDeep:
                    return GenerateCollectionDeepMapping(prop);

                default:
                    return $"source.{prop.SourcePropertyName}";
            }
        }

        private string GenerateNullableToNonNullableMapping(PropertyMapping prop)
        {
            var sourceTypeString = prop.SourceType;
            var destTypeString = prop.Type;

            // Handle nullable reference types (string? -> string)
            if (sourceTypeString.EndsWith("?"))
            {
                var defaultValue = GetDefaultValueForType(destTypeString);
                return $"source.{prop.SourcePropertyName} ?? {defaultValue}";
            }

            // Handle nullable value types (int? -> int)
            if (sourceTypeString.StartsWith("System.Nullable<") || sourceTypeString.Contains("?"))
            {
                var defaultValue = GetDefaultValueForType(destTypeString);
                return $"source.{prop.SourcePropertyName} ?? {defaultValue}";
            }

            // Fallback to direct assignment
            return $"source.{prop.SourcePropertyName}";
        }

        private string GetDefaultValueForType(string typeName)
        {
            switch (typeName)
            {
                case "string":
                    return "string.Empty";
                case "int":
                    return "0";
                case "long":
                    return "0L";
                case "double":
                    return "0.0";
                case "float":
                    return "0.0f";
                case "decimal":
                    return "0m";
                case "bool":
                    return "false";
                case "DateTime":
                    return "DateTime.MinValue";
                case "Guid":
                    return "Guid.Empty";
                default:
                    if (typeName.EndsWith("[]"))
                        return "new " + typeName + " { }";
                    if (typeName.StartsWith("List<"))
                        return "new " + typeName + "()";
                    return "default(" + typeName + ")";
            }
        }

        private string GenerateCollectionDirectMapping(PropertyMapping prop)
        {
            // For collections with same element types, we can directly assign or convert
            if (prop.Type.Contains("List<"))
            {
                if (prop.SourceType.Contains("List<"))
                {
                    return $"source.{prop.SourcePropertyName}"; // List to List, same type
                }
                else if (prop.SourceType.Contains("[]"))
                {
                    return $"source.{prop.SourcePropertyName}?.ToList()"; // Array to List
                }
            }
            else if (prop.Type.Contains("[]"))
            {
                if (prop.SourceType.Contains("List<"))
                {
                    return $"source.{prop.SourcePropertyName}?.ToArray()"; // List to Array
                }
                else if (prop.SourceType.Contains("[]"))
                {
                    return $"source.{prop.SourcePropertyName}"; // Array to Array
                }
            }

            return $"source.{prop.SourcePropertyName}";
        }

        private string GenerateCollectionDeepMapping(PropertyMapping prop)
        {
            var sourceElementType = ExtractTypeName(prop.SourceCollectionElementType);
            var destElementType = ExtractTypeName(prop.CollectionElementType);
            var mapClass = $"Map{sourceElementType}To{destElementType}";
            if (prop.Type.Contains("List<"))
            {
                return $"{mapClass}.ListProjectionCompiled(source.{prop.SourcePropertyName})";
            }
            else if (prop.Type.Contains("[]"))
            {
                return $"{mapClass}.ArrayProjectionCompiled(source.{prop.SourcePropertyName})";
            }
            else
            {
                // Generic collection, default to ListProjectionCompiled
                return $"{mapClass}.ListProjectionCompiled(source.{prop.SourcePropertyName})";
            }
        }

        private string ExtractTypeName(string fullTypeName)
        {
            if (string.IsNullOrEmpty(fullTypeName))
                return "";

            // Remove namespace and extract just the type name
            var parts = fullTypeName.Split('.');
            var typeName = parts.Last();

            // Remove generic parameters for generic types
            if (typeName.Contains('<'))
            {
                typeName = typeName.Substring(0, typeName.IndexOf('<'));
            }

            return typeName;
        }
    }
}
