# YourTools.Mapper

YourTools.Mapper is a .NET source generator for object mapping. It enables fast, compile-time mapping between different object types, reducing boilerplate and improving performance.

## Features
- Attribute-based mapping configuration
- Custom mapping profiles
- Ignore properties with attributes
- Source generator for high performance

## Getting Started
Add the NuGet package to your project:

```
dotnet add package YourTools.Mapper
```

Annotate your classes with mapping attributes and implement mapping profiles as needed. See the [documentation](https://yourtools.example.com) for details.


## Defining a Mapper Profile
A Mapper Profile in YourTools.Mapper allows you to configure how objects are mapped between types. To define a profile:

1. Inherit from `MapperProfile`.
2. Override the `Configure` method and use the provided `MapperConfiguration` to set up your mappings.

> **Note:** If you are not interested in projections, use `config.EnableProjectionFunctions = false;` in your profile configuration. This will prevent the generator from emitting LINQ projection expressions and compiled delegates.

### Example
```csharp
using YourTools.Mapper;

public class YourToolsMapperProfile : MapperProfile
{
    public override void Configure(MapperConfiguration config)
    {
        // Enable projection functions (for LINQ and compiled delegates)
        config.EnableProjectionFunctions = true;
        // If you do NOT want projections, set to false:
        // config.EnableProjectionFunctions = false;

        // Simple mapping with reverse
        config.CreateMap<PersonModel, PersonEntity>().Reverse();

        // Custom member mapping and ignore
        config.CreateMap<ProductModel, ProductEntity>()
            .ForMember(dest => dest.Id, source => Guid.NewGuid().ToString() + "#125")
            .Ignore(dest => dest.Manufacturer);

        // Reverse mapping for customized ones
        config.CreateMap<ProductEntity, ProductModel>();

        // Custom mapping function
        config.CreateMap<BalanceEntity, BalanceModel>()
            .WithCustomMapping(StaticMappers.MapBalanceModelToBalanceEntity);

        // Reverse mapping for custom mapping
        config.CreateMap<BalanceModel, BalanceEntity>();
    }
}

public class StaticMappers
{
    public static BalanceModel MapBalanceModelToBalanceEntity(BalanceEntity model)
    {
        return new BalanceModel
        {
            Id = model.Id,
            UserId = model.UserId,
            Amount = model.Amount,
            CreatedAt = model.CreatedAt,
            UpdatedAt = model.UpdatedAt,
            IsDeleted = model.IsDeleted
        };
    }
}
```

### Key Features
- **Reverse Mapping**: Use `.Reverse()` to generate mappings in both directions.
- **Custom Member Mapping**: Use `.ForMember()` to customize how individual properties are mapped.
- **Ignore Properties**: Use `.Ignore()` to skip mapping specific properties.
- **Custom Mapping Functions**: Use `.WithCustomMapping()` to provide your own mapping logic.

For more details, see the sample profile in `Application/YourToolsMapperProfile.cs`.

## Dependency Injection Registration
To use YourTools.Mapper with .NET Dependency Injection, register the mapping handlers and obtain an `IMapper` instance as follows:

```csharp
using Microsoft.Extensions.DependencyInjection;
using YourTools.Mapper;

var services = new ServiceCollection();
services.RegisterMappingHandlers();

var sp = services.BuildServiceProvider();
var myMapper = sp.GetRequiredService<IMapper>();
```

- `RegisterMappingHandlers()` scans and registers all mapping profiles and handlers.
- You can now inject or resolve `IMapper` anywhere in your application.

This approach works seamlessly with ASP.NET Core or any .NET application using Microsoft.Extensions.DependencyInjection.

## What is being generated

YourTools.Mapper Source Generator produces several types of files to support mapping and DI registration:

### 1. DI Registration Extension
This code provides DI registration for all mapping components, including the core mapper, dispatcher, and individual mapping handlers:

```csharp
// <auto-generated />
using Microsoft.Extensions.DependencyInjection;
using YourTools.Mapper;
using Application.Models.ViewModels;
using Application.Models.Entities;

namespace YourTools.Mapper.Generated
{
    // Provides a single extension point to register all source-generated mapping components into DI.
    // Adds: IMapper (core implementation), IGeneratedMappingDispatcher (fast jump-table dispatcher),
    // and each concrete IMap<TSource,TDestination> handler for direct resolution / testing / fallback.
    // Safe to call once at application startup (idempotent with typical DI containers registering singletons).
    // Generated at 2025-08-20T14:30:12.4508116+02:00
    public static class MappingServiceExtensions
    {
        /// <summary>Registers all generated mapping services (mapper, dispatcher, individual handlers).</summary>
        public static IServiceCollection RegisterMappingHandlers(this IServiceCollection services, System.Action<MapperConfiguration> configure = null)
        {
            services.AddSingleton<IMapper, Mapper>();
            services.AddSingleton<IGeneratedMappingDispatcher, GeneratedMappingDispatcher>();

            return services;
        }
    }
}
```

This generated code ensures all mapping services are registered in your DI container, making it easy to resolve and use mapping functionality throughout your application.

### 2. Mapping Logic Example
This code shows a typical generated mapping class for converting between models and entities, including support for collections, nested objects, and LINQ projection expressions:

```csharp
// <auto-generated />
using System;
using System.Linq;
using YourTools.Mapper;
using Application.Models.ViewModels;
using Application.Models.Entities;

namespace YourTools.Mapper.Generated
{
    // Generated at 2025-08-20T14:30:12.4508531+02:00
    public static class MapPersonModelToPersonEntity
    {
        public static global::Application.Models.Entities.PersonEntity MapToPersonEntity(this global::Application.Models.ViewModels.PersonModel source)
        {
            if (source == null) return null;

            return new global::Application.Models.Entities.PersonEntity
            {
                Email = source.Email,
                Age = source.Age,
                Name = source.Name,
                Certificate = source.Certificate == null ? null : MapCertificateModelToCertificateEntity.MapToCertificateEntity(source.Certificate),
                Addresses = MapAddressModelToAddressEntity.ListProjectionCompiled(source.Addresses)
            };
        }

        public static System.Collections.Generic.List<global::Application.Models.Entities.PersonEntity> MapListToPersonEntity(System.Collections.Generic.List<global::Application.Models.ViewModels.PersonModel> source) => YourTools.Mapper.CodeGeneration.MapCollectionHelpers.MapList<global::Application.Models.ViewModels.PersonModel,global::Application.Models.Entities.PersonEntity>(source, x => x.MapToPersonEntity());
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]

        public static global::Application.Models.Entities.PersonEntity[] MapArrayToPersonEntity(global::Application.Models.ViewModels.PersonModel[] source)
        {
            if (source == null) return null;
            var result = new global::Application.Models.Entities.PersonEntity[source.Length];
            for (int i = 0; i < source.Length; i++)
                result[i] = source[i].MapToPersonEntity();
            return result;
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static global::Application.Models.Entities.PersonEntity[] MapListToPersonEntityArray(System.Collections.Generic.List<global::Application.Models.ViewModels.PersonModel> source)
        {
            if (source == null) return null;
            var result = new global::Application.Models.Entities.PersonEntity[source.Count];
            for (int i = 0; i < source.Count; i++)
                result[i] = source[i].MapToPersonEntity();
            return result;
        }

        public static System.Collections.Generic.List<global::Application.Models.Entities.PersonEntity> MapArrayToPersonEntityList(global::Application.Models.ViewModels.PersonModel[] source) => YourTools.Mapper.CodeGeneration.MapCollectionHelpers.MapArrayToList<global::Application.Models.ViewModels.PersonModel,global::Application.Models.Entities.PersonEntity>(source, x => x.MapToPersonEntity());

        /// <summary>Expression for single item projection using Map method.</summary>
        public static System.Linq.Expressions.Expression<System.Func<global::Application.Models.ViewModels.PersonModel, global::Application.Models.Entities.PersonEntity>> Projection => source => source.MapToPersonEntity();

        /// <summary>Expression for List<TSource> projection using list mapping method.</summary>
        public static System.Linq.Expressions.Expression<System.Func<System.Collections.Generic.List<global::Application.Models.ViewModels.PersonModel>, System.Collections.Generic.List<global::Application.Models.Entities.PersonEntity>>> ListProjection => list => MapListToPersonEntity(list);

        public static readonly System.Func<System.Collections.Generic.List<global::Application.Models.ViewModels.PersonModel>, System.Collections.Generic.List<global::Application.Models.Entities.PersonEntity>> ListProjectionCompiled = ListProjection.Compile();

        /// <summary>Expression for array projection using array mapping method.</summary>
        public static System.Linq.Expressions.Expression<System.Func<global::Application.Models.ViewModels.PersonModel[], global::Application.Models.Entities.PersonEntity[]>> ArrayProjection => array => MapArrayToPersonEntity(array);

        public static readonly System.Func<global::Application.Models.ViewModels.PersonModel[], global::Application.Models.Entities.PersonEntity[]> ArrayProjectionCompiled = ArrayProjection.Compile();
    }
}
```

This generated mapping class provides efficient conversion between types, including support for arrays, lists, nested objects, and LINQ projections for advanced scenarios.

### 3. Generated Mapping Dispatcher Example
A dispatcher is also generated to provide ultra-fast, reflection-free mapping between types. It uses type checks to route conversions for single objects, arrays, and lists. This enables efficient runtime mapping without reflection:

```csharp
// <auto-generated />
using System;
using System.Runtime.CompilerServices;
using YourTools.Mapper;
using Application.Models.ViewModels;
using Application.Models.Entities;

namespace YourTools.Mapper.Generated
{
    // This static helper provides ultra-fast dispatch for generated mappings without reflection.
    // It uses a sequence of exact type checks (jump table style) to route source->destination conversions.
    // Generic TryMap<TSource,TDestination> covers strongly-typed calls; TryMapObj handles runtime (object) scenarios.
    // Collection variants (List<> / array combinations) are inlined so we avoid per-element reflection overhead.
    // Generated at 2025-08-20T14:38:48.6885480+02:00
    internal static class __GeneratedMappingDispatcherStatic
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static bool TryMapArray(object source, Type sourceType, Type destType, out object result)
        {
            if (source is null) { result = null!; return true; }
            if (sourceType == typeof(PersonModel[]) && destType == typeof(PersonEntity[])) { result = MapPersonModelToPersonEntity.MapArrayToPersonEntity((PersonModel[])source)!; return true; }
            // ...other type checks...
            result = null!; return false;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static bool TryMapList(object source, Type sourceType, Type destType, out object result)
        {
            if (source is null) { result = null!; return true; }
            if (sourceType == typeof(System.Collections.Generic.List<PersonModel>) && destType == typeof(System.Collections.Generic.List<PersonEntity>)) { result = MapPersonModelToPersonEntity.MapListToPersonEntity((System.Collections.Generic.List<PersonModel>)source)!; return true; }
            // ...other type checks...
            result = null!; return false;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static bool TryMapSingleObject(object source, Type sourceType, Type destType, out object result)
        {
            if (source is null) { result = null!; return true; }
            if (sourceType == typeof(PersonModel) && destType == typeof(PersonEntity)) { result = ((PersonModel)source).MapToPersonEntity(); return true; }
            // ...other type checks...
            result = null!; return false;
        }
    }

    public sealed class GeneratedMappingDispatcher : IGeneratedMappingDispatcher
    {
        public bool TryMapArray(object source, Type sourceType, Type destType, out object result)
            => __GeneratedMappingDispatcherStatic.TryMapArray(source, sourceType, destType, out result);

        public bool TryMapList(object source, Type sourceType, Type destType, out object result)
            => __GeneratedMappingDispatcherStatic.TryMapList(source, sourceType, destType, out result);

        public bool TryMapSingleObject(object source, Type sourceType, Type destType, out object result)
            => __GeneratedMappingDispatcherStatic.TryMapSingleObject(source, sourceType, destType, out result);
    }
}
```

This dispatcher enables fast, type-safe mapping at runtime, avoiding reflection and supporting arrays, lists, and single objects.

## Benchmarks

Performance is a key focus of YourTools.Mapper. Benchmarks are provided to demonstrate mapping speed, memory usage, and comparison to other mapping libraries.

Benchmark code and scenarios can be found in the `YourTools.Benchmarks/` project.

### Example Benchmark: Mapping a Complex Person Object

The following sample is used to benchmark mapping a complex `PersonEntity` object:

```csharp
PersonEntity PersonSample = new()
{
    Email = $"person@mail.com",
    Age = 10,
    Name = $"Person Name ",
    Certificate = new CertificateEntity()
    {
        CertificateId = $"CertId ",
        CertificateName = $"Certificate Name ",
        ExpiryDate = DateTime.Now
    },
    Addresses =
    [
        new()
        {
            Street = $"Street ",
            City = $"City ",
            ZipCode = $"ZipCode ",
        }
    ]
};
```

![Complex Object Mapping Benchmark](screenshots/MappingBenchmarksComplexObject.png)

*Example: Mapping speed comparison for a single complex object using YourTools.Mapper, Mapster, and AutoMapper.*

---

### Example Benchmark: Mapping Order Object

The following sample is used to benchmark mapping `OrderEntity` object:

```csharp
OrderEntity _OrderEntity = new()
{
    Id = 1,
    OrderNumber = "OrderNumber",
    OrderDate = DateTime.Now,
    TotalAmount = 10,
    CustomerName = "CustomerName",
    CustomerEmail = "CustomerEmail",
    ShippingAddress = "ShippingAddress",
    BillingAddress = "BillingAddress",
    OrderStatus = $"Pending ",
    ShippedDate = DateTime.Now,
    DeliveredDate = DateTime.Now,
    TrackingNumber =  $"Pending 11",
    PaymentMethod = $"Pending 9",
    Notes = $"Pending 10",
    CustomerPhone = $"Pending 1",
    CustomerAddress = $"Pending 2",
    CustomerCity = $"Pending 3",
    CustomerState = $"Pending 4",
    CustomerZipCode = $"Pending 5",
    CustomerCountry = $"Pending 6",
    CustomerCompany = $"Pending 7",
    CustomerTaxId = $"Pending 8",
};
```

![Order Entity Mapping Benchmark](screenshots/MappingBenchmarksOrderEntity.png)

*Example: Mapping speed comparison for a single complex order object using YourTools.Mapper, Mapster, and AutoMapper.*
